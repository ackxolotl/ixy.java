// Include all the plugins this module depends on
plugins {
	id 'java'                                               // Java library plugin
	id 'jacoco'                                             // Java Code Coverage
	id 'pmd'                                                // Static code analyzer
	id 'io.freefair.aggregate-javadoc-jar' version '3.6.4'  // Aggregated JavaDoc
	id 'com.github.ben-manes.versions'     version '0.21.0' // Outdated dependencies detection support
}

// Configure the group and version of the project, which should match the root project's
group 'de.tum.in.net.ixy'
version '1.0'

// Use BinTray's jCenter repository, which is faster and bigger than Maven's
repositories {
	jcenter()
}

// Define a set of custom properties which may or may not be useful, but should be inherited from the root project
ext {
	DEBUG     = true
	UNSAFE    = true
	OPTIMIZED = false
	HUGE_MNT  = "/mnt/huge"
}

// Define the location for plugin JARs
ext.pluginsDir = rootProject.buildDir.path + '/plugins'

// Compile all subprojects as dependencies
dependencies {
	compile project(':ixy.app')
	compile project(':ixy.ixgbe')
}

// Merges the test execution data of all subprojects into a single file
task jacocoTestMerge(type: JacocoMerge) {
	destinationFile = file("${buildDir}/jacoco/all.exec")
	executionData = files("${buildDir}/jacoco/test.exec")
}

// Use the execution data from all the projects to compute code coverage with JaCoCo
jacocoTestReport {
	dependsOn jacocoTestMerge
	executionData.from = jacocoTestMerge.destinationFile
}

// Task that creates an aggregated test report
task aggregateTest(type: TestReport, dependsOn: test) {
	destinationDir = file("${buildDir}/reports/tests")
}

// Task that creates an aggregated PMD report of the source files
task aggregatePmdMain(type: Pmd) {
	reports {
		html.destination = file("${buildDir}/reports/pmd/main.html")
		xml.destination = file("${buildDir}/reports/pmd/main.xml")
	}
}

// Build always the uberjar
build.dependsOn ':ixy.app:uberjar'

// Add the execution data files to the merge task
def first = true;
subprojects.each {
	it.afterEvaluate {
		aggregateTest.reportOn it.test
		if (file(it.test.jacoco.destinationFile).exists()) {
			jacocoTestMerge.dependsOn it.jacocoTestReport
			if (first) {
				first = false;
				jacocoTestMerge.executionData = files(it.test.jacoco.destinationFile)
			} else {
				jacocoTestMerge.executionData += files(it.test.jacoco.destinationFile)
			}
		}
		jacocoTestReport.sourceSets it.sourceSets.main
//		aggregatePmdMain.sourceSets.main << it.sourceSets.main
	}
}
